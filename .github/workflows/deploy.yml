name: üöÄ Deploy to EKS

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: lugx-cluster-man
  EKS_NAMESPACE: lux-gaming
  STACK_NAME: lugx-gaming-eks-infrastructure

jobs:
  check-and-create-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      cluster-exists: ${{ steps.check-cluster.outputs.exists }}
      cluster-status: ${{ steps.check-cluster.outputs.status }}
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîê Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üîç Check if EKS cluster exists
      id: check-cluster
      run: |
        echo "Checking if EKS cluster '${{ env.EKS_CLUSTER_NAME }}' exists..."
        
        # Check if cluster exists
        if aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "‚úÖ EKS cluster exists"
          CLUSTER_STATUS=$(aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --query 'cluster.status' --output text)
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "status=$CLUSTER_STATUS" >> $GITHUB_OUTPUT
          echo "CLUSTER_STATUS=$CLUSTER_STATUS" >> $GITHUB_ENV
        else
          echo "‚ùå EKS cluster does not exist"
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "status=NOT_FOUND" >> $GITHUB_OUTPUT
          echo "CLUSTER_STATUS=NOT_FOUND" >> $GITHUB_ENV
        fi
        
    - name: üèóÔ∏è Create EKS cluster if not exists
      if: steps.check-cluster.outputs.exists == 'false'
      run: |
        echo "üöÄ Creating EKS cluster using CloudFormation..."
        
        # Deploy CloudFormation stack
        aws cloudformation deploy \
          --template-file infastructure/cloudformation/eks-cluster.yaml \
          --stack-name ${{ env.STACK_NAME }} \
          --parameter-overrides \
            ClusterName=${{ env.EKS_CLUSTER_NAME }} \
            NodeGroupDesiredSize=2 \
            NodeGroupMinSize=1 \
            NodeGroupMaxSize=5 \
          --capabilities CAPABILITY_IAM \
          --region ${{ env.AWS_REGION }}
          
        echo "‚úÖ CloudFormation stack deployment initiated"
        
    - name: ‚è≥ Wait for EKS cluster to be ready
      if: steps.check-cluster.outputs.exists == 'false' || steps.check-cluster.outputs.status != 'ACTIVE'
      run: |
        echo "‚è≥ Waiting for EKS cluster to be in ACTIVE state..."
        
        # Wait for cluster to be active (max 30 minutes)
        timeout 1800 bash -c '
          while true; do
            STATUS=$(aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --query "cluster.status" --output text 2>/dev/null || echo "NOT_FOUND")
            echo "Current cluster status: $STATUS"
            
            if [ "$STATUS" = "ACTIVE" ]; then
              echo "‚úÖ EKS cluster is now ACTIVE"
              break
            elif [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "DELETING" ]; then
              echo "‚ùå EKS cluster creation failed with status: $STATUS"
              exit 1
            fi
            
            echo "‚è≥ Waiting 30 seconds before next check..."
            sleep 30
          done
        '
        
    - name: üîó Configure kubectl
      run: |
        echo "üîó Configuring kubectl for cluster ${{ env.EKS_CLUSTER_NAME }}..."
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
        # Verify connection
        kubectl get nodes
        echo "‚úÖ kubectl configured successfully"

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: check-and-create-infrastructure
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: üîê Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üîó Configure kubectl
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: üîê Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        
    - name: üèóÔ∏è Build and push Frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./lux-frontend
        push: true
        tags: |
          rajithawan/lugx-frontend-image:latest
          rajithawan/lugx-frontend-image:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: üèóÔ∏è Build and push User Service image
      uses: docker/build-push-action@v5
      with:
        context: ./lugx-backend/services/user
        push: true
        tags: |
          rajithawan/lugx-user-image:latest
          rajithawan/lugx-user-image:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: üèóÔ∏è Build and push Game Service image
      uses: docker/build-push-action@v5
      with:
        context: ./lugx-backend/services/game
        push: true
        tags: |
          rajithawan/lugx-game-image:latest
          rajithawan/lugx-game-image:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: üèóÔ∏è Build and push Order Service image
      uses: docker/build-push-action@v5
      with:
        context: ./lugx-backend/services/order
        push: true
        tags: |
          rajithawan/lugx-order-image:latest
          rajithawan/lugx-order-image:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: üèóÔ∏è Build and push Analytics Service image
      uses: docker/build-push-action@v5
      with:
        context: ./lugx-backend/services/analytics
        push: true
        tags: |
          rajithawan/lugx-analytics-image:latest
          rajithawan/lugx-analytics-image:${{ github.sha }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: üîÑ Update Kubernetes manifests
      run: |
        # Update image tags in deployment files
        sed -i "s|rajithawan/lugx-frontend-image:.*|rajithawan/lugx-frontend-image:${{ github.sha }}|g" k8s/frontend-deployment.yaml
        sed -i "s|rajithawan/lugx-user-image:.*|rajithawan/lugx-user-image:${{ github.sha }}|g" k8s/user-deployment.yaml
        sed -i "s|rajithawan/lugx-game-image:.*|rajithawan/lugx-game-image:${{ github.sha }}|g" k8s/game-deployment.yaml
        sed -i "s|rajithawan/lugx-order-image:.*|rajithawan/lugx-order-image:${{ github.sha }}|g" k8s/order-deployment.yaml
        sed -i "s|rajithawan/lugx-analytics-image:.*|rajithawan/lugx-analytics-image:${{ github.sha }}|g" k8s/analytics-service-deployment.yaml
        
    - name: ‚è≥ Wait for AWS Load Balancer Controller
      run: |
        echo "‚è≥ Waiting for AWS Load Balancer Controller to be ready..."
        
        # Wait for the controller to be ready
        timeout 300 bash -c '
          while true; do
            if kubectl get deployment aws-load-balancer-controller -n kube-system >/dev/null 2>&1; then
              REPLICAS=$(kubectl get deployment aws-load-balancer-controller -n kube-system -o jsonpath="{.status.readyReplicas}" 2>/dev/null || echo "0")
              if [ "$REPLICAS" -ge "1" ]; then
                echo "‚úÖ AWS Load Balancer Controller is ready"
                break
              fi
            fi
            echo "‚è≥ Waiting for AWS Load Balancer Controller deployment... (current ready replicas: $REPLICAS)"
            sleep 10
          done
        '
        
        # Verify webhook is working
        kubectl get validatingwebhookconfiguration aws-load-balancer-webhook-configuration-v9 || \
        kubectl get validatingwebhookconfiguration | grep aws-load-balancer-webhook || \
        echo "‚ö†Ô∏è  Webhook configuration not found, but proceeding..."
        
        echo "‚úÖ AWS Load Balancer Controller verification completed"
        
    - name: üöÄ Deploy to EKS
      run: |
        # Apply namespace
        kubectl apply -f k8s/namespace.yaml
        
        # Apply ConfigMap and Secret
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secret.yaml
        kubectl apply -f k8s/analytics-secret.yaml
        
        # Apply deployments
        kubectl apply -f k8s/frontend-deployment.yaml
        kubectl apply -f k8s/user-deployment.yaml
        kubectl apply -f k8s/game-deployment.yaml
        kubectl apply -f k8s/order-deployment.yaml
        kubectl apply -f k8s/analytics-service-deployment.yaml
        
        # Apply services
        kubectl apply -f k8s/frontend-service.yaml
        kubectl apply -f k8s/user-service.yaml
        kubectl apply -f k8s/game-service.yaml
        kubectl apply -f k8s/order-service.yaml
        kubectl apply -f k8s/analytics-service.yaml
        
        # Apply ingress
        kubectl apply -f k8s/ingress.yaml
        
        # Wait for deployments to be ready
        kubectl rollout status deployment/frontend-service -n ${{ env.EKS_NAMESPACE }} --timeout=300s
        kubectl rollout status deployment/user-service -n ${{ env.EKS_NAMESPACE }} --timeout=300s
        kubectl rollout status deployment/game-service -n ${{ env.EKS_NAMESPACE }} --timeout=300s
        kubectl rollout status deployment/order-service -n ${{ env.EKS_NAMESPACE }} --timeout=300s
        kubectl rollout status deployment/analytics-service -n ${{ env.EKS_NAMESPACE }} --timeout=300s
        
    - name: ‚úÖ Verify deployment
      run: |
        # Check pod status
        kubectl get pods -n ${{ env.EKS_NAMESPACE }}
        
        # Check services
        kubectl get services -n ${{ env.EKS_NAMESPACE }}
        
        # Check ingress
        kubectl get ingress -n ${{ env.EKS_NAMESPACE }}
        
    - name: üß™ Run health checks
      run: |
        # Wait for services to be ready
        sleep 30
        
        # Test frontend
        kubectl port-forward -n ${{ env.EKS_NAMESPACE }} service/frontend-service 8080:80 &
        sleep 10
        curl -f http://localhost:8080 || echo "Frontend health check failed"
        pkill -f "port-forward.*frontend-service"
        
        # Test user service
        kubectl port-forward -n ${{ env.EKS_NAMESPACE }} service/user-service 8081:80 &
        sleep 10
        curl -f http://localhost:8081/health/user || echo "User service health check failed"
        pkill -f "port-forward.*user-service"
        
        # Test game service
        kubectl port-forward -n ${{ env.EKS_NAMESPACE }} service/game-service 8082:80 &
        sleep 10
        curl -f http://localhost:8082/health/game || echo "Game service health check failed"
        pkill -f "port-forward.*game-service"
        
        # Test order service
        kubectl port-forward -n ${{ env.EKS_NAMESPACE }} service/order-service 8083:80 &
        sleep 10
        curl -f http://localhost:8083/health/order || echo "Order service health check failed"
        pkill -f "port-forward.*order-service"
        
        # Test analytics service
        kubectl port-forward -n ${{ env.EKS_NAMESPACE }} service/analytics-service 8084:80 &
        sleep 10
        curl -f http://localhost:8084/health/analytics || echo "Analytics service health check failed"
        pkill -f "port-forward.*analytics-service"
        
    - name: üìä Deployment Summary
      if: always()
      run: |
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Cluster:** ${{ env.EKS_CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "**Cluster Status:** ${{ needs.check-and-create-infrastructure.outputs.cluster-status }}" >> $GITHUB_STEP_SUMMARY
        echo "**Namespace:** ${{ env.EKS_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.check-and-create-infrastructure.outputs.cluster-exists }}" = "false" ]; then
          echo "### üèóÔ∏è Infrastructure Created:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ New EKS cluster created: ${{ env.EKS_CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ VPC and networking configured" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Node group provisioned" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ AWS Load Balancer Controller installed" >> $GITHUB_STEP_SUMMARY
        else
          echo "### üîÑ Infrastructure Status:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Used existing EKS cluster: ${{ env.EKS_CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üì¶ Deployed Images:" >> $GITHUB_STEP_SUMMARY
        echo "- Frontend: rajithawan/lugx-frontend-image:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- User Service: rajithawan/lugx-user-image:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- Game Service: rajithawan/lugx-game-image:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- Order Service: rajithawan/lugx-order-image:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- Analytics Service: rajithawan/lugx-analytics-image:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY